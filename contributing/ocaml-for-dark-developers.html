<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>OCaml for Dark developers · Dark Documentation</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="This guide aims to introduce you to enough OCaml to contribute to Dark, assuming you already know Dark."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="OCaml for Dark developers · Dark Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://darklang.github.io/docs/"/><meta property="og:description" content="This guide aims to introduce you to enough OCaml to contribute to Dark, assuming you already know Dark."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/docs/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-159199190-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-159199190-1');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/docs/js/scrollSpy.js"></script><link rel="stylesheet" href="/docs/css/main.css"/><script src="/docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/docs/"><img class="logo" src="/docs/img/favicon.ico" alt="Dark Documentation"/><h2 class="headerTitleWithLogo">Dark Documentation</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/introduction" target="_self">Documentation</a></li><li class=""><a href="/docs/tutorials/tutorial-intro" target="_self">Tutorials &amp; Samples</a></li><li class=""><a href="/docs/slack-apps/slack-intro" target="_self">Building Slack Apps</a></li><li class="siteNavGroupActive"><a href="/docs/contributing/getting-started" target="_self">Contributing</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Working in the Dark repo</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Your First Contribution</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/contributing/getting-started">Getting started</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/setting-up-the-repo">Setting up the Dark repo</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/adding-your-first-test">Adding your first test</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/making-your-first-pull-request">Making your first Pull Request</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Your Next Contributions</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/contributing/next-contribution">Your next contribution</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/if-you-dont-know-ocaml">If you don&#x27;t know OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/adding-a-function">Adding a built-in function</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/adding-a-language-feature">Adding a language feature</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/adding-a-refactoring">Adding a refactoring</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Working in the Dark repo</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/contributing/ocaml-for-dark-developers">OCaml for Dark developers</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/general-concepts">General concepts</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/tour-of-editor">A tour of the Editor</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/tour-of-backend">A tour of the Backend</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/repo-layout">Repository directory structure</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/glossary">Glossary</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/debugging">Debugging</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing/making-a-pull-request">Making a Pull Request</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">OCaml for Dark developers</h1></header><article><div><span><p>This guide aims to introduce you to enough OCaml to contribute to Dark, assuming you already know Dark.</p>
<h2><a class="anchor" aria-hidden="true" id="ocaml-vs-reasonml-vs-bucklescript---whats-the-difference"></a><a href="#ocaml-vs-reasonml-vs-bucklescript---whats-the-difference" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml vs ReasonML vs Bucklescript - what's the difference?</h2>
<p>The backend is in OCaml and the frontend is in Bucklescript. Also, something about ReasonML. What's the difference? The simplest answer is that these are all the same.</p>
<p>Bucklescript and OCaml are both compilers:</p>
<ul>
<li>the native OCaml compiler compiles programs to binaries. The backend uses native OCaml.</li>
<li>the Bucklescript compiler compiles programs to JS. The editor uses Bucklescript.</li>
</ul>
<p>ReasonML and OCaml are both syntaxes:</p>
<ul>
<li>ReasonML is a JS-like syntax for the OCaml language</li>
<li>OCaml has a default syntax (we use this in the Dark repo for both the backend and the client)</li>
</ul>
<p>ReasonML is also often used to refer to the community around compiling to JS using Bucklescript, and associated technologies.</p>
<p>Again, the simplest mental model is that all the words mean the same thing.</p>
<p>Specifically:</p>
<ul>
<li>the Dark backend uses the native OCaml compiler and the OCaml syntax</li>
<li>the Dark client uses the Bucklescript compiler, and the OCaml syntax.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="some-simple-ocaml-code"></a><a href="#some-simple-ocaml-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Some simple OCaml code</h2>
<p>Dark and OCaml are very similar. Here's an OCaml function:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> someFunction (intArgument : <span class="hljs-built_in">int</span>) : <span class="hljs-built_in">string</span> =
  <span class="hljs-keyword">let</span> aString = <span class="hljs-string">"myString"</span> <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">let</span> anInt = <span class="hljs-number">65</span> + intArgument <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">let</span> aFloat = <span class="hljs-number">6.72</span> <span class="hljs-keyword">in</span>
  anotherFunction aString anInt aFloat
</code></pre>
<p>This is a function called <code>someFunction</code>, which takes one argument, an
<code>int</code> called <code>intArgument</code>, and returns a <code>string</code>. Three variables are
defined in the body, first a string, then an int, then a float, and
finally we call the <code>anotherFunction</code> function with all three
parameters as arguments.</p>
<p>In Dark this would be written:</p>
<pre><code class="hljs css language-ocaml">someFunction
  intArgument : <span class="hljs-type">Int</span>
  ↪ <span class="hljs-type">String</span>

<span class="hljs-keyword">let</span> aString = <span class="hljs-string">"myString"</span>
<span class="hljs-keyword">let</span> anInt = <span class="hljs-number">65</span> + intArgument
<span class="hljs-keyword">let</span> aFloat = <span class="hljs-number">6.72</span>
anotherFunction aString anInt aFloat
</code></pre>
<p>As you can see, apart from how the function is written, the only
difference is that <code>let</code> statements in OCaml have an <code>in</code> at the end of
the line.</p>
<h2><a class="anchor" aria-hidden="true" id="dark-vs-ocaml"></a><a href="#dark-vs-ocaml" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dark vs OCaml</h2>
<p>OCaml is a very large influence on Dark, and Dark will continue to grow some
more of OCaml's features. We'll discuss the similarities and differences as we
go through language features.</p>
<h3><a class="anchor" aria-hidden="true" id="syntax"></a><a href="#syntax" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax</h3>
<p>Since Dark doesn't let you type syntax, it doesn't have syntax errors.
OCaml has syntax errors, and the error messages are not good. I tend to
make sure that my code syntax checks by running <code>oCamlformat</code> in my
editor on save: if it reformats, then the syntax was good.</p>
<h3><a class="anchor" aria-hidden="true" id="types"></a><a href="#types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Types</h3>
<p>OCaml is a strongly typed-language. Dark aspires to be, but it doesn't
have a type-checker yet. This shows the biggest difference in working
in OCaml, that the compiler will refuse to compile if the types are
wrong.</p>
<p>OCaml has type-inference, which means that the compiler will try and
figure out what the types are. This is frequently the source of bad
compiler messages, often it will tell you something which seems wrong
because it guessed wrong about certain types.</p>
<p>Usually type errors actually contain useful information, but they need to be
read very carefully to find it.</p>
<p>We've found the best way to debug incorrect types is to add type annotations to
everything. We add them to all functions (we didn't always do this, but we do
now, but we are now), including all parameters and return types (see
<a href="#functions">example</a> below).</p>
<p>You can actually add types in many places where they aren't required, such as
variable definitions:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> y = <span class="hljs-number">6.7</span> <span class="hljs-keyword">in</span>
<span class="hljs-keyword">let</span> (x : <span class="hljs-built_in">int</span>) = <span class="hljs-number">6</span> <span class="hljs-keyword">in</span>
x + <span class="hljs-number">5</span>
</code></pre>
<p><code>x</code> here, despite being a normal variable definition, has a type
signature. OCaml allows this in many places, and it's useful for
tracking down these errors.</p>
<p>We'll discuss declaring types below.</p>
<h3><a class="anchor" aria-hidden="true" id="functions"></a><a href="#functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functions</h3>
<p>Functions in OCaml are defined in the outer scope. Type signatures are optional in OCaml
but required in the Dark codebase:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myFunction (arg1 : <span class="hljs-built_in">int</span>) (arg2 : <span class="hljs-built_in">string</span>) : <span class="hljs-built_in">string</span> = 
  <span class="hljs-keyword">if</span> arg1 &lt; (<span class="hljs-type">String</span>.toInt arg2)
  <span class="hljs-keyword">then</span> <span class="hljs-string">"just return a string"</span>
  <span class="hljs-keyword">else</span> arg2
</code></pre>
<p>Here, <code>myFunction</code> has two arguments, <code>arg1</code> and <code>arg2</code>, which are an
<code>int</code> and <code>string</code> respectively. It returns a <code>string</code>.</p>
<p>Like in Dark, the body of a function is just an expression, and it
automatically returns the result of that expression.</p>
<p>(see <a href="#advanced-functions">below</a> for more details on functions in OCaml)</p>
<h3><a class="anchor" aria-hidden="true" id="standard-library"></a><a href="#standard-library" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Standard library</h3>
<p>Most of the code in Dark uses
<a href="https://github.com/darklang/tablecloth">Tablecloth</a>, which has the same
<a href="https://github.com/darklang/tablecloth/blob/master/bucklescript/src/tablecloth.ml">interface</a>
for Bucklescript and native OCaml.</p>
<p>A lot of the backend uses Core, one of the most popular standard libraries for
OCaml. The Jane Street Core library has three flavors: Base, Core_kernel and
Core, each with progressively more expansive functionality.  The native version
of Tablecloth is built on top of &quot;Base&quot;. The Dark backend typically uses
<a href="https://ocaml.janestreet.com/ocaml-core/v0.11/doc/core_kernel/Core_kernel/index.html">Core_kernel</a>
as we have not transitioned to Tablecloth fully.</p>
<p>Note: we try to use Core_kernel directly when implementing the language and
standard libraries, as Tablecloth is still in flux and has not yet reached
stability.</p>
<h3><a class="anchor" aria-hidden="true" id="int"></a><a href="#int" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Int</h3>
<p>An <code>int</code> is the same in Dark and OCaml, same syntax, same meaning. While Dark
intends to one day support infinite precision integers, today it uses 63-bit
integers, which is the same as OCaml.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span> <span class="hljs-keyword">in</span>
x + <span class="hljs-number">6</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="float"></a><a href="#float" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Float</h3>
<p>A <code>float</code> is the same in Dark and OCaml, both of them are 64-bit floating point
numbers.</p>
<p>In OCaml, there are special operators to work on floats:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0.1</span> <span class="hljs-keyword">in</span>
x +. <span class="hljs-number">0.3</span>
</code></pre>
<p>To convert from floats to ints use <code>Float.toInt</code>, or <code>Float.round</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="bool"></a><a href="#bool" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bool</h3>
<p>Like in Dark, <code>bool</code>s in OCaml are either <code>true</code> or <code>false</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="string"></a><a href="#string" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>String</h3>
<p>A String in Dark is Unicode (UTF-8), while a <code>string</code> in OCaml is just bytes
(we use the <code>Unicode_string</code> module to convert them to Unicode).</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myString = <span class="hljs-string">"some string, escaping is allowed\nwhich dark doesn't support yet"</span> <span class="hljs-keyword">in</span>
myString
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>List</h3>
<p>Lists in Dark and OCaml are almost the same. In OCaml, lists use <code>;</code> as separators, like so:</p>
<pre><code class="hljs css language-ocaml">[<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>; <span class="hljs-number">4</span>]
</code></pre>
<p>While Dark technically allows you to create lists that have different
types in them, OCaml emphatically does not.</p>
<p>To type check a list, you specify it's type like so: <code>int list</code>, which is a list of ints.</p>
<h3><a class="anchor" aria-hidden="true" id="records"></a><a href="#records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Records</h3>
<p>Records are mostly used as objects are in most languages. Like Dark, they only
have fields, not methods, and you use functions to manipulate them.</p>
<p>A record in OCaml has unusual syntax:</p>
<pre><code class="hljs css language-ocaml">{
  field1 = <span class="hljs-number">56</span>;
  field2 = <span class="hljs-literal">true</span>;
  field3 = <span class="hljs-string">"asd"</span>
}
</code></pre>
<p>Note that they use <code>=</code> to connect a field and a value, and <code>;</code> as row
separator. The types of the fields do not have to be declared.</p>
<p>Records are immutable, like almost everything in OCaml, and are updated using an unusual syntax:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> x = { field1 = <span class="hljs-number">56</span>; field2 = <span class="hljs-literal">true</span> } <span class="hljs-keyword">in</span>
<span class="hljs-keyword">let</span> updatedX = { x <span class="hljs-keyword">with</span> field1 = <span class="hljs-number">57</span> } <span class="hljs-keyword">in</span>
doSomethingWith updatedX
</code></pre>
<p>Note that records in Dark are really dictionaries, which is why you
update them with <code>Dict::set</code>. We're trying to figure out how to split
records and dictionaries apart better in Dark, after which they will be
more like OCaml (though hopefully with better syntax).</p>
<p>Type definitions for records look like this:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> person =
  {
    name : <span class="hljs-built_in">string</span>
  ; age : <span class="hljs-built_in">int</span>
  }
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="let"></a><a href="#let" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let</h3>
<p>OCaml <code>let</code>s have a slightly different syntax to Dark:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> x = <span class="hljs-number">45</span> <span class="hljs-keyword">in</span>
x + <span class="hljs-number">23</span>
</code></pre>
<p>The <code>in</code> at the end is required.</p>
<p><code>let</code> also allow destructing in OCaml, although we don't currently use that
very often.</p>
<h3><a class="anchor" aria-hidden="true" id="if"></a><a href="#if" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>If</h3>
<p><code>if</code> statements in OCaml are extremely similar to Dark, including that they
only allow <code>bool</code>s as the condition, and in their syntax.</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">if</span> hasAccess user
<span class="hljs-keyword">then</span> <span class="hljs-string">"Welcome!"</span>
<span class="hljs-keyword">else</span> <span class="hljs-string">"Access denied"</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="operators"></a><a href="#operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operators</h3>
<p>OCaml, in keeping with its odd syntax, has some unusual operators. Most
importantly, the equality operator is <code>=</code> (that's just one equals), whereas in
most languages it's <code>==</code> or <code>===</code>. <code>=</code> is very strict equality, equivalent to
<code>===</code> in languages that have that, such as JS.</p>
<p>Dark's <code>==</code> is the same as OCaml's <code>=</code>. OCaml also has a <code>==</code> operator, but you
should never use it.</p>
<p>OCaml's inequality operator (<code>!=</code> in Dark) is <code>&lt;&gt;</code>. Most of its comparison
operators (such as <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, etc) only operate on integers.</p>
<h3><a class="anchor" aria-hidden="true" id="match"></a><a href="#match" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Match</h3>
<p>Dark has a <code>match</code> statement that is very similar to OCaml's, with slightly
different syntax:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">match</span> myValue <span class="hljs-keyword">with</span>
| <span class="hljs-type">Some</span> x -&gt; <span class="hljs-number">5</span>
| _ -&gt; <span class="hljs-number">6</span>
</code></pre>
<p>Notice the <code>with</code> keyword, and starting the patterns with <code>|</code>.</p>
<p>OCaml also supports more powerful <code>match</code>es, for example multiple patterns can match a single branch:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">match</span> myValue <span class="hljs-keyword">with</span>
| <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span> -&gt; <span class="hljs-string">"between 4 and 6"</span>
| _ -&gt; <span class="hljs-string">"not between 4 and 6"</span>
</code></pre>
<p>OCaml also supports the <code>when</code> clause:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">match</span> myValue <span class="hljs-keyword">with</span>
| <span class="hljs-type">Some</span> myInt <span class="hljs-keyword">when</span> myInt &gt;= <span class="hljs-number">4</span> &amp;&amp; myInt &lt;= <span class="hljs-number">6</span> -&gt; <span class="hljs-string">"between 4 and 6"</span>
| _ -&gt; <span class="hljs-string">"not between 4 and 6"</span>
</code></pre>
<p>Be careful of very subtle bugs when combining multiple patterns with <code>when</code>
clauses: the entire pattern will fail if the pattern matches when the clause
does not:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myValue = <span class="hljs-type">Some</span> <span class="hljs-number">5</span> <span class="hljs-keyword">in</span>
<span class="hljs-keyword">match</span> myValue <span class="hljs-keyword">with</span>
| <span class="hljs-type">Some</span> <span class="hljs-number">4</span> | <span class="hljs-type">Some</span> myInt <span class="hljs-keyword">when</span> myValue &lt;&gt; <span class="hljs-type">Some</span> <span class="hljs-number">4</span> -&gt; <span class="hljs-string">"this will never succeed"</span>
| _ -&gt; <span class="hljs-string">"this will succeed as a fallback"</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="variants"></a><a href="#variants" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variants</h3>
<p>Dark has a handful of enums for <code>Option</code> and <code>Result</code> types: <code>Just</code>, <code>Nothing</code>, <code>Ok</code> and <code>Error</code>. In the future we will expand this to allow user-defined types as well.</p>
<p>OCaml supports the <code>Option</code> and <code>Result</code> types and we use them a lot. However, the constructors for Option OCaml are named differently: <code>Some</code> and <code>None</code>.</p>
<p>OCaml calls enums &quot;variants&quot;. We use them frequently, especially to represent expressions. For example in <code>FluidExpression.ml</code>:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> t =
  | <span class="hljs-type">EInteger</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span>
  | <span class="hljs-type">EBool</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">bool</span>
  | <span class="hljs-type">EString</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span>
  | <span class="hljs-type">EFloat</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * <span class="hljs-built_in">string</span>
  | <span class="hljs-type">ENull</span> <span class="hljs-keyword">of</span> id
  | <span class="hljs-type">EBlank</span> <span class="hljs-keyword">of</span> id
  | <span class="hljs-type">ELet</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * t * t
  | <span class="hljs-type">EIf</span> <span class="hljs-keyword">of</span> id * t * t * t
  | <span class="hljs-type">EBinOp</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * t * t * sendToRail
  | <span class="hljs-type">ELambda</span> <span class="hljs-keyword">of</span> id * (analysisID * <span class="hljs-built_in">string</span>) <span class="hljs-built_in">list</span> * t
  | <span class="hljs-type">EFieldAccess</span> <span class="hljs-keyword">of</span> id * t * <span class="hljs-built_in">string</span>
  | <span class="hljs-type">EVariable</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span>
  | <span class="hljs-type">EFnCall</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * t <span class="hljs-built_in">list</span> * sendToRail
  | <span class="hljs-type">EPartial</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * t
  | <span class="hljs-type">ERightPartial</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * t
  | <span class="hljs-type">ELeftPartial</span> <span class="hljs-keyword">of</span> <span class="hljs-type">Shared</span>.id * <span class="hljs-built_in">string</span> * t
  | <span class="hljs-type">EList</span> <span class="hljs-keyword">of</span> id * t <span class="hljs-built_in">list</span>
  | <span class="hljs-type">ERecord</span> <span class="hljs-keyword">of</span> id * (<span class="hljs-built_in">string</span> * t) <span class="hljs-built_in">list</span>
  | <span class="hljs-type">EPipe</span> <span class="hljs-keyword">of</span> id * t <span class="hljs-built_in">list</span>
  | <span class="hljs-type">EConstructor</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * t <span class="hljs-built_in">list</span>
  | <span class="hljs-type">EMatch</span> <span class="hljs-keyword">of</span> id * t * (<span class="hljs-type">FluidPattern</span>.t * t) <span class="hljs-built_in">list</span>
  | <span class="hljs-type">EPipeTarget</span> <span class="hljs-keyword">of</span> id
  | <span class="hljs-type">EFeatureFlag</span> <span class="hljs-keyword">of</span> id * <span class="hljs-built_in">string</span> * t * t * t
</code></pre>
<p>Type <code>t</code> (it's a common convention in OCaml to name the main type of a module
<code>t</code>) must be one of <code>EInteger</code>, <code>EBool</code>, <code>EString</code>, etc. <code>EInteger</code> takes two
parameters, an <code>id</code> and a <code>string</code> (we use a string to represent integers as
Bucklescript doesn't have a big enough integer type).</p>
<p>To create a <code>t</code>, you'd do something like this:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> expr = <span class="hljs-type">EInteger</span> (id, <span class="hljs-string">"test"</span>)
</code></pre>
<p>To get values from them, you pattern match:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">match</span> expr <span class="hljs-keyword">with</span>
| <span class="hljs-type">EInteger</span> (_, str) -&gt; str
| _ -&gt; <span class="hljs-string">"not an int"</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lambdas"></a><a href="#lambdas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas</h3>
<p>OCaml supports lambdas and we use them frequently. They have a different syntax to Dark:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-built_in">list</span>
|&gt; <span class="hljs-type">List</span>.map ~f:(<span class="hljs-keyword">fun</span> elem -&gt; elem + <span class="hljs-number">2</span>)
</code></pre>
<p>It's very common to use functions like <code>List.map</code> which have a parameter called <code>f</code> which take a lambda.</p>
<h3><a class="anchor" aria-hidden="true" id="pipes"></a><a href="#pipes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pipes</h3>
<p>OCaml has pipes which are the same as in Dark, except that in OCaml the pipe
goes into the final position (in Dark it goes into the first position):</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-built_in">list</span>
|&gt; <span class="hljs-type">List</span>.map ~f:(<span class="hljs-keyword">fun</span> elem -&gt; elem + <span class="hljs-number">3</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="dictionaries"></a><a href="#dictionaries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dictionaries</h3>
<p>Dictionaries (hash-maps, etc) are typically called <code>Map</code> in OCaml, and are
unfortunately pretty hard to use, which is one reason you won't see them used
as much as they really should be.</p>
<h3><a class="anchor" aria-hidden="true" id="unit"></a><a href="#unit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unit</h3>
<p>OCaml has a <code>unit</code> type, whose only member is <code>()</code>. That's an actual value, for example, all this is valid code:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> falseVar = <span class="hljs-literal">()</span> != <span class="hljs-literal">()</span> <span class="hljs-keyword">in</span>
</code></pre>
<p>It's typically used to pass to a function which is impure but doesn't have any
meaningful arguments, such as <code>gid ()</code> (which generates IDs).</p>
<h3><a class="anchor" aria-hidden="true" id="error-handling"></a><a href="#error-handling" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Error handling</h3>
<p>Typically we use <code>Result</code> or <code>Option</code>s for error handling. You'll very commonly see something like</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> isRailable (m : model) (name : <span class="hljs-built_in">string</span>) =
  m.functions
  |&gt; <span class="hljs-type">Functions</span>.find name
  |&gt; <span class="hljs-type">Option</span>.map ~f:(<span class="hljs-keyword">fun</span> fn -&gt;
         fn.fnReturnTipe = <span class="hljs-type">TOption</span> || fn.fnReturnTipe = <span class="hljs-type">TResult</span>)
  |&gt; <span class="hljs-type">Option</span>.withDefault ~default:<span class="hljs-literal">false</span>
</code></pre>
<p>To find out if a function goes on the error rail, we search for a function,
which returns an Option. We then use a <code>map</code> to operate on the option, and
finally choose a default in case the Option returned <code>None</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="exceptions"></a><a href="#exceptions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exceptions</h4>
<p>OCaml also has exceptions - we hardly use them in the client, but unfortunately
use them a little bit on the backend, which we'd like to do less of.</p>
<p>Unfortunately, it's hard to tell in OCaml when an exception could be thrown.</p>
<h3><a class="anchor" aria-hidden="true" id="mli-files"></a><a href="#mli-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.mli</code> files</h3>
<p>OCaml code goes in <code>.ml</code> files - each file is a module. OCaml also has interface
files (<code>.mli</code>) which describe the module in the <code>.ml</code> file of the same name.</p>
<p>While they aren't necessary, they make it easier to know what functions are
unused, they make APIs clearer, and they make compilation faster. As such, Dark
is moving towards an <code>.mli</code> for each <code>.ml</code> file.</p>
<h3><a class="anchor" aria-hidden="true" id="imperative-programming"></a><a href="#imperative-programming" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Imperative programming</h3>
<p>OCaml supports imperative programming which is not in Dark yet. There are mutable values called refs, that can be updated:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myString = <span class="hljs-built_in">ref</span> <span class="hljs-string">"old value"</span> <span class="hljs-keyword">in</span>
myString := <span class="hljs-string">"new value"</span>; <span class="hljs-comment">(* update contents of myString *)</span>
print_endline myString
</code></pre>
<p>To go along with it, OCaml has <code>for</code> and <code>while</code> loop, allowing you to use
imperative programming in places where it's clearer to do so:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n_jobs <span class="hljs-literal">()</span> <span class="hljs-keyword">do</span>
  do_next_job <span class="hljs-literal">()</span>
<span class="hljs-keyword">done</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="advanced-functions"></a><a href="#advanced-functions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced functions</h3>
<h4><a class="anchor" aria-hidden="true" id="named-parameters"></a><a href="#named-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Named parameters</h4>
<p>Functions support named parameters, which you might see called like this (note the <code>~</code>):</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-type">Option</span>.withDefault ~default:<span class="hljs-number">5</span> (<span class="hljs-type">Some</span> <span class="hljs-number">5</span>)
</code></pre>
<p>These are useful as a named parameter can be placed in any order (this
is also useful for piping).</p>
<p>You declare functions with named parameters like so:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myFunction (regularParamter : <span class="hljs-built_in">int</span>) ~(namedParam : <span class="hljs-built_in">string</span>) : <span class="hljs-built_in">int</span> =
  ...body <span class="hljs-keyword">of</span> <span class="hljs-keyword">function</span>...
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="optional-parameters"></a><a href="#optional-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional parameters</h4>
<p>OCaml also supports optional parameters</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myFunction ?(optionalParam = <span class="hljs-number">3</span>) (regularParamter : <span class="hljs-built_in">int</span>) : <span class="hljs-built_in">int</span> =
  ...body <span class="hljs-keyword">of</span> <span class="hljs-keyword">function</span>...
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="the-rec-and-and-keywords"></a><a href="#the-rec-and-and-keywords" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>the <code>rec</code> and <code>and</code> keywords</h4>
<p>By default, OCaml functions are not recursive: they cannot call themselves. To allow a function to call itself, add the <code>rec</code> keyword:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> myFunction (var : <span class="hljs-built_in">int</span>) : <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">if</span> var &gt; <span class="hljs-number">6</span> <span class="hljs-keyword">then</span> <span class="hljs-number">6</span>
  <span class="hljs-keyword">else</span> myFunction (var + <span class="hljs-number">2</span>)
</code></pre>
<p>Similarly, if two functions need to call each other, they need to be aware of each other (OCaml programs require all functions to be defined before they are used). The <code>and</code> keyword allows this:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> firstFunction (var : <span class="hljs-built_in">int</span>) =
  (secondFunction var) + <span class="hljs-number">2</span>

<span class="hljs-keyword">and</span> secondFunction (var : <span class="hljs-built_in">int</span>) =
  <span class="hljs-keyword">if</span> var &gt; <span class="hljs-number">6</span>
  <span class="hljs-keyword">then</span> firstFunction <span class="hljs-number">0</span>
  <span class="hljs-keyword">else</span> firstFunction (var + <span class="hljs-number">1</span>)
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="partial-application--currying"></a><a href="#partial-application--currying" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Partial application / currying</h4>
<p>Occasionally you'll see a function called with fewer arguments than it has parameters:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myFunction (param1: <span class="hljs-built_in">int</span>) (param2 : <span class="hljs-built_in">string</span>) =
  ...body...

<span class="hljs-keyword">let</span> myOtherFunction = myFunction <span class="hljs-number">6</span>
</code></pre>
<p>This is called &quot;partial application&quot;, in that the function is only partially called (this is often called Currying in the functional language community). This just means that some parameters are filled in, and you now have a function which can be called with the remaining parameters:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> =
  myOtherfunction <span class="hljs-string">"final argument"</span>
</code></pre>
<p>This is the same as if it were defined as:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> myOtherFunction (param : <span class="hljs-built_in">string</span>) =
  myFunction <span class="hljs-number">6</span> param
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="modules"></a><a href="#modules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modules</h3>
<p>OCaml has a complex module system, which takes some time to grasp. Modules can have parameters, have inheritance, and each other these features uses a complicated, difficult to grasp syntax.</p>
<p>We only barely use modules in the Dark codebase, so here's what you need to know:</p>
<ul>
<li><p>all files are automatically modules. Note that in the backend,
modules need to have their directory names included, but not in the
client.</p></li>
<li><p>using a module is simple:</p></li>
</ul>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">open</span> <span class="hljs-type">MyModule1</span> <span class="hljs-comment">(* all function and types are available *)</span>
<span class="hljs-keyword">module</span> <span class="hljs-type">M</span> = <span class="hljs-type">MyModule2</span> <span class="hljs-comment">(* access members as if the module was called M *)</span>

<span class="hljs-keyword">let</span> x = <span class="hljs-type">MyModule3</span>.myFunction <span class="hljs-number">6</span>
</code></pre>
<ul>
<li>the syntax of creating a module is also straightforward:</li>
</ul>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">MyModule</span> = <span class="hljs-keyword">struct</span>
  <span class="hljs-keyword">type</span> t = <span class="hljs-built_in">int</span>
  <span class="hljs-keyword">let</span> myfunction x = x + <span class="hljs-number">2</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>We typically <code>open</code> the <code>Prelude</code> and <code>Types</code> modules at the top of all
files (which in turn open other modules, like <code>Tablecloth</code> on the
client).</p>
<h3><a class="anchor" aria-hidden="true" id="classes-and-objects"></a><a href="#classes-and-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Classes and Objects</h3>
<p>OCaml supports traditional object oriented programming, though it's not used
very much and very discouraged. The only place we really use it for
interacting with JS (the Bucklescript JS interop code compiles it to direct OO
in JS).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/contributing/adding-a-refactoring"><span class="arrow-prev">← </span><span>Adding a refactoring</span></a><a class="docs-next button" href="/docs/contributing/general-concepts"><span>General concepts</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#ocaml-vs-reasonml-vs-bucklescript---whats-the-difference">OCaml vs ReasonML vs Bucklescript - what's the difference?</a></li><li><a href="#some-simple-ocaml-code">Some simple OCaml code</a></li><li><a href="#dark-vs-ocaml">Dark vs OCaml</a><ul class="toc-headings"><li><a href="#syntax">Syntax</a></li><li><a href="#types">Types</a></li><li><a href="#functions">Functions</a></li><li><a href="#standard-library">Standard library</a></li><li><a href="#int">Int</a></li><li><a href="#float">Float</a></li><li><a href="#bool">Bool</a></li><li><a href="#string">String</a></li><li><a href="#list">List</a></li><li><a href="#records">Records</a></li><li><a href="#let">Let</a></li><li><a href="#if">If</a></li><li><a href="#operators">Operators</a></li><li><a href="#match">Match</a></li><li><a href="#variants">Variants</a></li><li><a href="#lambdas">Lambdas</a></li><li><a href="#pipes">Pipes</a></li><li><a href="#dictionaries">Dictionaries</a></li><li><a href="#unit">Unit</a></li><li><a href="#error-handling">Error handling</a></li><li><a href="#mli-files"><code>.mli</code> files</a></li><li><a href="#imperative-programming">Imperative programming</a></li><li><a href="#advanced-functions">Advanced functions</a></li><li><a href="#modules">Modules</a></li><li><a href="#classes-and-objects">Classes and Objects</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2020 Dark</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '1e1c6adb6b62f53c456dc70e833c2c26',
                indexName: 'darklang',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>